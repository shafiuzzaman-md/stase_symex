# STASE Symbolic Execution Workflow (STASE_SYMEX)

STASE_SYMEX combines static-analysis findings with KLEE-based symbolic execution to confirm the vulnerability and extract the vulnerability preconditions. 

---

## Input

| Item | Notes |
|------|-------|
| Source-code directory | Any UEFI / kernel module tree. |
| Driver `.c` (under `inputs/`) | Contains symbolic declarations, stubs, and the entry-point call. Generated by `setup_driver.py`, then hand-edited for new stubs (if needed). |
| Vulnerability type | One of `OOB_WRITE`, `WWW` (write-what-where) or `CFH` (control-flow hijack). |
| Assertion line # | Line number of the vulnerable instruction. |
| KLEE timeout (optional) | Defaults to 5 s. |

---

## Output


---

## Step 1: Setup Environment

Run **once** to set up the environment and prepare environment-wide stubs and includes.

```
python3 setup_environment.py <source-code-location> <clang-path> <klee-path>


```
Example:
```
python3 setup_edk2_environment.py ../edk2-testcases-main /usr/lib/llvm-14/bin/clang /home/shafi/klee_build/bin/klee
```
The script:

- copies the source tree into `stase_generated/instrumented_source/`

- rewrites `#include <...>` to `#include "..."` absolute ones

- comments out all `STATIC_ASSERT()` macros

- extracts GUIDs & globals → `global_stubs.h` and `global_stub_defs.c`

- creates a settings.py containing paths to Clang, KLEE, and source

## Step 2: Setup Driver and Instrument code
Run once for each vulnerability detected by static analysis to generate a KLEE driver and insert assertion.
```
python3 setup_driver.py \
  --entry-src   <path/to/entrypoint.c> \
  --entry-func  <EntryPointSymbol> \
  --vuln        <OOB_WRITE|WWW|CFH> \
  --assert-line <N> \
  --target-src  <same/or/other/file.c> \
  --symbolic    "type name"   [...] \
  --concrete    "stmt;"       [...] \
  --global/-g   "type name"   [...] \
  --assertion   "<expr for klee_assert>"


```
Example:
```
python3 setup_driver.py \
  --entry-src  Testcases/Sample2Tests/CharConverter/CharConverter.c \
  --entry-func Iconv \
  --vuln       OOB_WRITE \
  --assert-line 146 \
  --target-src Testcases/Sample2Tests/CharConverter/CharConverter.c \
  -g          "unsigned OutputBuffer_cap" \
  --symbolic  "unsigned OutputBuffer_cap" \
  --symbolic  "ICONV_T *CharDesc" \
  --symbolic  "CHAR8 *InputBuffer" \
  --symbolic  "INTN InputSize" \
  --symbolic  "CHAR8 **OutputBuffer" \
  --symbolic  "INTN *OutputSize" \
  --concrete  "klee_assume(OutputBuffer_cap >= 1 && OutputBuffer_cap <= 4096);" \
  --concrete  "*OutputBuffer = malloc(OutputBuffer_cap);" \
  --assertion "OutIndex < OutputBuffer_cap"

```
The script:
- inserts the assertion at the specified line into the target source (assertion template depends on OOB_WRITE / WWW / CFH).
- writes a skeleton driver →
    ```
    klee_driver_<EntryPointName>_<VulnerabilityType>_<LineNumber>.c

    ```
    For example:
    ```
    inputs/klee_driver_CharConverter_OOB_WRITE_146.c
    ```
  - includes all dependent headers
  - allocates / marks symbolic every --symbolic variable
  - copies any --concrete statements
  - calls the entry-point

### Human-in-the-loop edits
Update the generated driver if needed:

- Add function stubs (if needed) for the uninteresting functions

- Add initialization for system globals

## Step 3: Run Symbolic Analysis

Once the driver and assertion are ready:

```
python3 run_analysis.py <driver.c> [<max_klee_time_seconds>]

```

Example:
```
python3 run_analysis.py \
  ../inputs/klee_driver_Iconv_OOB_WRITE_146.c \
  10
```
This will:

- Compile the driver with stubs into LLVM bitcode

- Run KLEE with the specified (or default 5s) timeout.

##  Project Layout
```
project_root/
├── stase_symex/
│   ├── setup_environment.py
│   ├── setup_driver.py
│   ├── run_analysis.py
│   └── (other helper scripts)
├── stase_generated/
│   ├── instrumented_source/            # Copied + instrumented source tree
│   ├── generated_klee_drivers/
│   ├── global_stubs.h
│   ├── global_stub_defs.c
│   ├── driver_stubs.c
│   └── settings.py
├── inputs/
│   └── klee_driver_<...>.c             # User-prepared drivers
└── (user's original source code placed anywhere)

```
