# STASE Symbolic Execution Workflow (STASE_SYMEX)
STASE_SYMEX combines static-analysis results with KLEE‑based symbolic execution to confirm the vulnerability and extract the path constraints that trigger it.

---

## Input

| Item | Notes |
|------|-------|
| Source tree| Any UEFI / kernel module code base. |
| Vulnerability type |`OOB_WRITE`, `WWW` (write-what-where) or `CFH` (control-flow hijack). |
| Assertion location | Line number of the vulnerable instruction (in --target-src). |
| Driver `.c` (under `inputs/`) | Contains symbolic declarations, stubs, and the entry-point call. Generated by `setup_driver.py`, then hand-edited for new stubs (if needed). |
| KLEE timeout (optional) | Seconds (default 5). |

---

## Output
- After run_analysis.py finishes you will find a KLEE output folder (e.g. stase_generated/klee-out-0/).
- STASE_SYMEX post‑processes this folder and writes two parallel reports that describe every assertion that KLEE managed to violate.
  
| Report name               | Type / format | Description                                                                                                                                                                                                                                                                   |
| ------------------------- | ------------- | -------------------------------------------------------------------------- |
| **`report_pre_post.txt`** | Human‑readable pre‑/post‑condition dump   | Human‑oriented dump of every failing path.<br>▪ **Pre‑conditions** – the symbolic constraints (as KLEE SMT‑queries) that let execution hit the vulnerable line.<br>▪ **Post‑condition** – the exact runtime failure (assert‑fail) and its source location. |
| **`report_vulns.json`**   | Machine‑readable JSON          | Machine‑friendly list of counter‑examples.<br>Each element has:<br>```json { "type": , "file": , "line": , "variables": , "assertion": "(query …)" } ```            |

---

## Step 1: Setup Environment

Run **once** to set up the environment and prepare environment-wide stubs and includes.

```
python3 setup_environment.py <source-code-location> <clang-path> <klee-path>
```
Copies the tree to stase_generated/instrumented_source/, rewrites local
includes, comments out STATIC_ASSERT(), extracts thousands of UEFI globals
into global_stub_defs.c, and writes settings.py (paths for Clang & KLEE).

Example on EDK II:
```
python3 setup_edk2_environment.py ../edk2-testcases-main /usr/lib/llvm-14/bin/clang /home/shafi/klee_build/bin/klee
```

## Step 2: Setup Driver and Instrument code
### 2.1  Quick reference
Run once for each vulnerability detected by static analysis to generate a KLEE driver and insert assertion.
```
python3 setup_driver.py \
  --entry-src   <path/to/entrypoint.c>     \
  --entry-func  <EntryPointSymbol>         \
  --vuln        <OOB_WRITE|WWW|CFH>        \
  --assert-line <N>                        \
  --target-src  <same/or/other/file.c>     \
  --assertion   "<expr inside klee_assert>"\
  --symbolic    "type name"   [...]        \
  --concrete    "stmt;"       [...]        \
  --global/-g   "type name"   [...]        \
  --malloc      "ptr size"    [...]        \
  --default-malloc <size|0>
```
- `--symbolic`   Declares a var in main() and calls klee_make_symbolic.
- `--concrete`   Add line(s) emitted into main() after the symbolic block (typical uses: extra malloc, klee_assume, stub initialisation).
- `--global / -g`   File‑scope globals – handy when a symbolic (or concrete) variable must be visible to the instrumented source file as well.
- `--malloc "ptr 2048"`   For a double pointer (T **buf) this pre‑allocates a 2048‑byte inner buffer and marks it symbolic. One `--malloc` per pointer.
- `--default-malloc N`   Any `T **ptr` without an explicit `--malloc` receives an `N`‑byte symbolic inner buffer (set `0` to leave it `NULL`).


### 2.2  End‑to‑end example
```
python3 setup_driver.py \
  --entry-src   Testcases/Sample2Tests/CharConverter/CharConverter.c \
  --entry-func  Iconv \
  --vuln        OOB_WRITE \
  --assert-line 146 \
  --target-src  Testcases/Sample2Tests/CharConverter/CharConverter.c \
  -g           "unsigned OutputBuffer_cap" \
  --symbolic   "ICONV_T *CharDesc" \
  --symbolic   "CHAR8 *InputBuffer" \
  --symbolic   "INTN InputSize" \
  --symbolic   "CHAR8 **OutputBuffer" \
  --symbolic   "INTN *OutputSize" \
  --malloc     "OutputBuffer 4096" \
  --concrete   "klee_assume(OutputBuffer_cap >= 1 && OutputBuffer_cap <= 4096);" \
  --assertion  "OutIndex < OutputBuffer_cap"
```
Results:
```
inputs/klee_driver_Iconv_OOB_WRITE_146.c
stase_generated/instrumented_source/.../CharConverter.c   (now contains klee_assert)
```

## Step 3: Run Symbolic Analysis

Once the driver and assertion are ready:

```
python3 run_analysis.py <driver.c> [<max_klee_time_seconds>]

```

Example (run for 10 s):
```
python3 run_analysis.py \
  ../inputs/klee_driver_Iconv_OOB_WRITE_146.c \
  10
```

- Builds the driver + stubs with Clang ‑O0.
- Runs KLEE with --max-time=<timeout>
- Results land in stase_generated/klee-out‑*.

## Step 4: Human-in-the-loop edits (if needed)
| What happens                                                    | What to do                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| --------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Build fails** – `undefined reference`, “conflicting types” …  | Add a *stub* for every uninteresting function: ```EFI_STATUS EFIAPI UnusedProtocol (VOID) { return EFI_UNSUPPORTED;}``` <br>Put it **above `main()` in the driver**.<br> Re‑run **Step 3**.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| **KLEE finishes instantly** – no counter‑examples, no new paths | Confirm that execution can actually reach the vulnerable instruction:<br>1. Edit the instrumented source in `stase_generated/instrumented_source/.../<target>.c`. <br>2. Insert a probe **just before** the real assertion.```klee_assert(0);   /* reachability probe */```<br>3. Re‑run ***Step 3**.<br>   \* If KLEE now stops on the `0` probe → the path is reachable → replace the probe with your real assertion and go back to **Step 2 + 3**.<br>   \* If not reachable → Add function stubs for the uninteresting functions and loosen constraints (make more inputs symbolic, widen `klee_assume`, allocate bigger buffers) and iterate. |

##  Project Layout
```
project_root/
├── stase_symex/
│   ├── setup_environment.py
│   ├── setup_driver.py
│   ├── run_analysis.py
│   └── (other helper scripts)
├── stase_generated/
│   ├── instrumented_source/            # Copied + instrumented source tree
│   ├── generated_klee_drivers/
│   ├── global_stubs.h
│   ├── global_stub_defs.c
│   ├── driver_stubs.c
│   └── settings.py
├── inputs/
│   └── klee_driver_<...>.c             # User-prepared drivers
└── (user's original source code placed anywhere)

```
